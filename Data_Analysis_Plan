1. Data Loading and Preprocessing
  - for each data set load RNA-data with scanpy.read_10x_mtx() and the corresponding TCR-data with scirpy.read_10x_vdj()
  - for each data set merge the two different data type through scirpy.pp.merge_with_tcr()
  - assign sample, batch and tissue type labels to data set
  - merge all scanpy objects of data sets into a single scanpy object that contains data for all samples
 
2. QC and Filtering
 2.1 QC metrics
   - use scanpy.pp.calculate_qc_metrics() to compute QC metrics: 'n_cells_by_counts', 'mean_counts', 'log1p_mean_counts', 'pct_dropout_by_counts', 'total_counts', 'log1p_total_counts'
   - compute (i)total number of reads for each cell (ii) percentage of mitochondrial genes for each cell (iii) percentage ribosomal genes for each cell
   
 2.2 Bulk Filtering
   - filter out cells that express less than 200 genes
   - filter out genes that are expressed in less than 3 cells
   
 2.3 Sample-wise filtering
   - visualize (i)(ii)(iii) though violin plots and filter out cells that have too many reads, too high mitochondrial genes and too low ribosomal genes (whether or not to describe specific thresholds for each data set?)
   
 2.4 Genewise filtering
   - remove ribosomal, mitochondrial genes and MALAT1 gene
   
 2.5 TCR-data QC and filtering
   - visualize the counts for TCR chains --- # of cells with no TCR, one pair of TCR chains, two pair of TCR chains etc.
   - filtering out the cells that have more than two pairs of TCR chains
 
3. Cell Subsetting and Dimension Reduction
 3.1 Subset T cells from all cells
   - select all TCR and CD8 genes that exist in our samples and start with "TRAV","TRAJ","TRBV","TRBD","TRBJ","CD8A","CD8B", there are 160 genes in total
   - subset cells that express any of the above genes  (or equivalently speaking, exclude cells that TCR- and CD8-)
   - regress out the number of reads per cell to make library size the same across all cells
   - Scale data to unit variance and zero mean and truncate above 10 standard deviation
   
 3.2 Gene space dimension reduction
 In this step we choose a smaller number of the genes for downstream analysis
   - select top 200 highly variable genes for downstream analysis (including clustering with UMAP, cluster labelling)
   - Inject all of the important marker genes and important non-marker genes, in case they have been filtered out by the highly variable genes detection algorithm
   Genes used for downstream analysis is the union of all genes mentioned here plus 200 top variable genes
 3.3 Regressing out cell-cycle
   - obtain the cell-cycle genes from online study and regress them out by first compute the score of each of them with sc.tl.score_genes_cell_cycle(), second regressing out by the scores computed

 3.4 PCA
   - use ARPACK algorithm to perform PCA
   - choose 35 PC for downstream clustering
   - To determine the optimal PC usage, compute rand-indeces for UMAP clusterings with neighboring PC usages. Plotting the rand-indeces and we can see that it plateaus at around 35 PC
   
 3.5 Batch correction 
   - perform batch correction on one of the data copy, we use sc.external.pp.bbknn() to do this which is a wrapper for Batch Balanced K-Nearest-Neighbor algorithm 
   - BBKNN also creates a neighbor-graph that allows the run of UMAP  
   
 3.6 UMAP
   - derive UMAP from the neighbor graph produced by BBKNN algorithm, set min_dist=0.05
   - perform Leiden clustering algorithm
   - rank genes that characterize each cluster, based on T-scores
   
4. UMAP visualization
 4.0 The grand UMAP for all samples
 4.1 Distribution of cells by tissue types
 4.2 Distribution of cells by batches
 4.3 Distribution of cells by samples
 4.4 Distribution of genes by cell-cycles
 4.4 Heatmaps of proliferation markers
 4.5 Heatmaps of exhaustion markers
 4.6 Heatmaps of an array of requested genes (for labelling)

5. Cluster labelling (done mostly under the guidance of Hong-Sheng)
 - score genes in each cluster based on Differential Expression Tests (here we use all genes originally in all samples, instead of using the subset of genes for the clustering purpose)
 - based on the marker genes picked up in the above step and the gene heatmaps, we label the clusters

6. Subsetting Cells of Interest
 - choose subsets of the CTL cells
 - choose subsets of the memory T cells
 - export the count matrices for these trajectories for downstream pseudotime analysis

7. TSCAN for pseudotime reconstruction
 - read in the trajectories and their correponding count matrix
 - use TSCAN to create minimal spanning tree and projecting cells and clusters onto the tree stem
 - export pseudotime and trajectories for further uses

8. TCR QC
 - Examine the distribution of cells with TCR among the UMAP for a sanity check (the distribution of TCR should be compared with CD8, CD4 and CD45 gene heatmaps)

9. Clonotypes analysis
 9.1 Clonotype Network Construction
  - compute clonotype neibor-graph with ir.pp.ir_neighbors()
  - based on the neighbor-graph, compute clonotype clusters with ir.tl.define_clonotype_clusters(). Due to the fact that the clonotype motifs are short-sequences, we use identity metric for clustering.
  - Visualize the distribution of clonotypes by tissue types
  - Visualize the distribution of clonotypes by samples
 9.2 Clonotype Expansion and Diversity
  - compute the clonotype expansion with ir.tl.clonal_expansion()
  - Draw heapmap the clonal expansion by tissue types
  - Draw bar plots to show clonal expansion by samples (bar plot show the percentage of clonally expanded cells in each sample)
  - Draw bar plots to show most frequent clonotypes among all samples, color them by tissue type
  - Draw group abundance plot with shows the clonotype abundancy in each sample
  - compute clonal similarity for sanity check (samples from same subject should have more similar clonal repertoire)
  - compute clonal diversity based on Shannon entropy
 9.3 Most Frequent Clonal Types
  - plot the top 5 most frequent clonotypes
  - find the host samples for the most frequent clonotypes
  - choose the paired samples () and plot the shared clonotypes and exclusive clonotypes on the pair (used to help infer trajectories)
  - overlay the samples, clonotypes along the trajectories
 
10. 
   
   
